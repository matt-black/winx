{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"winx","text":"<p>N-dimensional window filtering in JAX.</p>"},{"location":"#introduction","title":"Introduction","text":"<p>Application of array filters that compute over the entire window (e.g. windowed median-filtering an image) cannot be done in <code>jax</code>. The closest mechanism is <code>jax.lax.reduce_window</code> but this requires the function to be a binary operation that compares elements within the window. <code>winx</code> provides this missing functionality, allowing users to construct arbitrary, window-based filters to an n-dimensional array.</p> <p>We provide an API that matches that of <code>scipy.ndimage</code>, notably a JAX-transformable implementation of <code>generic_filter</code>.</p> <p>We also provide an API similar to that of <code>jax.lax.conv_general_dilated</code> and <code>jax.lax.conv</code>, allowing for a similar approach to nonlinear filtering as used in (linear) convolution.</p>"},{"location":"#examples","title":"Examples","text":"<pre><code>import winx.ndimage as wndi\n</code></pre>"},{"location":"#installation","title":"Installation","text":""},{"location":"filter/","title":"<code>filter_window</code>","text":"<p>Core functionality of the library.</p>"},{"location":"filter/#winx.filter_window","title":"<code>winx.filter_window(x, fun, size, footprint=None, padding='same', mode='constant', cval=0, origin=0, window_strides=None, base_dilation=None, window_dilation=None, batch_size=None)</code>","text":"<p>Calculate a multidimensional filter using the given function.</p> <p>At each element of the input array, a window is generated, centered around that element, and the function is evaluated on that window.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>Array</code> <p>The input array.</p> required <code>fun</code> <code>Callable[[Array], Array]</code> <p>Function to apply at each element. Should take in a window and return a scalar.</p> required <code>size</code> <code>int | Sequence[int]</code> <p>Shape that is taken from the input array at every element position to define the input to the filter function. If an integer, a square (cubic, etc.) window with that size in each dimension will be used.</p> required <code>footprint</code> <code>Array</code> <p>A boolean array that delineates a window as well as which of the elements in that window gets passed to the filter function. If this is used, the values selected by the footprint are passed to <code>fun</code> as a 1-dimensional array. When <code>footprint</code> is given, <code>size</code> is ignored.</p> <code>None</code> <code>padding</code> <code>str</code> <p>Either the strings 'same' or 'valid'. 'same' adds padding to produce the same output size as the input. 'valid' does no padding, so only elements where the window fits completely in the image will be evaluated. Defaults to 'same'.</p> <code>'same'</code> <code>mode</code> <code>str</code> <p>Determines how the input array will be padded beyond its boundaries. Defaults to 'constant'. For valid values, see <code>jax.numpy.pad</code>.</p> <code>'constant'</code> <code>cval</code> <code>Number</code> <p>Value to fill past edges of input if <code>mode</code> is 'constant'. Defaults to 0.</p> <code>0</code> <code>origin</code> <code>int | Sequence[int]</code> <p>Controls the placement of the filter on the input's elements. A value of 0 (the default) centers the filter over the pixel. Positive values shift the filter to the left. Negative values shift the filter to the right.</p> <code>0</code> <code>window_strides</code> <code>Sequence[int]</code> <p>Inter-window strides. Defaults to <code>None</code>.</p> <code>None</code> <code>base_dilation</code> <code>Sequence[int]</code> <p>The dilation factor to apply to the input in each dimension. Defaults to <code>None</code>.</p> <code>None</code> <code>window_dilation</code> <code>Sequence[int]</code> <p>The dilation factor to apply to the window in each dimension. If None, no dilation is done. Defaults to <code>None</code>.</p> <code>None</code> <code>batch_size</code> <code>int</code> <p>Integer specifying the size of the batch for each step to execute in parallel. Under the hood, <code>jax.lax.map</code> will be used if this argument is not <code>None</code> whereas normally <code>jax.vmap</code> is used. Defaults to <code>None</code>.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>size</code> is specified as a sequence and the number of elements is not the same as the number of dimensions.</p> <p>Returns:</p> Name Type Description <code>Array</code> <code>Array</code> <p>The filtered array.</p> Notes <p>When using the <code>footprint</code> argument, the values passed to the filtering function will be a 1d array sorted in descending order.</p>"},{"location":"lax/","title":"<code>lax</code>","text":"<p>A <code>jax.lax</code>-like API that allows filters to be applied similar to how convolutions are applied in <code>jax</code>.</p>"},{"location":"lax/#winx.lax.filt","title":"<code>winx.lax.filt(x, fun, window_shape, window_strides, padding)</code>","text":"<p>Convenience wrapper around <code>filt_general_dilated</code>.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>Array</code> <p>A rank n+2 dimensional input array.</p> required <code>fun</code> <code>Callable[[Array], Union[Array, Numeric]]</code> <p>Filtering function to be applied to each window.</p> required <code>window_shape</code> <code>Sequence[int]</code> <p>Shape of the filtering window.</p> required <code>window_strides</code> <code>Sequence[int]</code> <p>Inter-window strides.</p> required <code>padding</code> <code>str | Sequence[Tuple[int, int]]</code> <p>Either the string 'same' or 'valid' or a sequence of tuples specifying padding applied to the left and right side of each dimension. Zero padding is used.</p> required <p>Returns:</p> Name Type Description <code>Array</code> <code>Array</code> <p>Filtered array.</p>"},{"location":"lax/#winx.lax.filt_general_dilated","title":"<code>winx.lax.filt_general_dilated(x, fun, window_shape, window_strides, padding, lhs_dilation=None, rhs_dilation=None, feature_group_count=1, batch_group_count=1)</code>","text":"<p>General n-dimensional filtering operation, with optional dilation.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>Array</code> <p>Rank n+2 dimensional input array.</p> required <code>fun</code> <code>Callable[[Array], Union[Array, Numeric]]</code> <p>Filtering function to be applied to each window.</p> required <code>window_shape</code> <code>Sequence[int]</code> <p>Shape of the window.</p> required <code>window_strides</code> <code>Sequence[int]</code> <p>Inter-window strides.</p> required <code>padding</code> <code>str | Sequence[Tuple[int, int]]</code> <p>Either the string 'same' or 'valid' or a sequence of tuples specifying padding applied to the left and right side of each dimension. Zero padding is used.</p> required <code>lhs_dilation</code> <code>Optional[Sequence[int]]</code> <p>The dilation factor to apply in each spatial dimension of the input. If None, no dilation is done. Defaults to None.</p> <code>None</code> <code>rhs_dilation</code> <code>Optional[Sequence[int]]</code> <p>The dilation factor to apply in each spatial dimension to the window (pre-filtering). If None, no dilation is done. Defaults to None.</p> <code>None</code> <code>feature_group_count</code> <code>int</code> <p>TODO. Defaults to 1.</p> <code>1</code> <code>batch_group_count</code> <code>int</code> <p>TODO. Defaults to 1.</p> <code>1</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>if input array, <code>x</code> is not at least 3-dimensional.</p> <code>NotImplementedError</code> <p>if <code>feature_group_count</code> or <code>batch_group_count</code> &gt; 1.</p> <p>Returns:</p> Name Type Description <code>Array</code> <code>Array</code> <p>Filtered array.</p> Notes <p>Right hand side dilation (<code>rhs_dilation</code>) is done, under the hood, by constructing a footprint similar to the mechanism used in <code>ndimage.generic_filter</code>. Thus, the filtering function will receive a 1D (sorted) array of values, not an ND array.</p>"},{"location":"ndimage/","title":"<code>ndimage</code>","text":"<p>A <code>scipy.ndimage</code>-like API.</p>"},{"location":"ndimage/#filters","title":"Filters","text":""},{"location":"ndimage/#winx.ndimage.gaussian_filter","title":"<code>winx.ndimage.gaussian_filter(x, sigma, order=0, mode='constant', cval=0.0, truncate=4.0, *, radius=0, axes=None, precision=None)</code>","text":"<p>Compute a multi-dimensional Gaussian filter.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>Num[Array]</code> <p>Input array</p> required <code>sigma</code> <code>float</code> <p>Standard deviation of Gaussian</p> required <code>order</code> <code>int</code> <p>Order of 0 is Gaussian, higher orders are derivatives, optional. Defaults to 0.</p> <code>0</code> <code>mode</code> <code>str</code> <p>How input array is extended beyond boundaries, optional. Defaults to 'constant'.</p> <code>'constant'</code> <code>cval</code> <code>float</code> <p>Value to use for <code>mode='constant'</code>, optional. Defaults to 0.</p> <code>0.0</code> <code>truncate</code> <code>float</code> <p>Truncate filter at this many std. dev's, optional. Defaults to 4.</p> <code>4.0</code> <code>radius</code> <code>int</code> <p>Radius of the filter. Overrides <code>truncate</code>, if provided.</p> <code>0</code> <code>axes</code> <code>int | Tuple[int, ...] | None</code> <p>Axis of <code>input</code> along which to calculate, optional. Defaults to -1.</p> <code>None</code> <code>precision</code> <code>PrecisionLike | None</code> <p>Precision to use for calculation, optional. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Array</code> <p>Array</p>"},{"location":"ndimage/#winx.ndimage.gaussian_filter1d","title":"<code>winx.ndimage.gaussian_filter1d(x, sigma, axis=-1, order=0, mode='constant', cval=0.0, truncate=4.0, *, radius=0, precision=None)</code>","text":"<p>Compute a 1-D gaussian filter.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>Array</code> <p>input array</p> required <code>sigma</code> <code>float</code> <p>standard deviation of Gaussian</p> required <code>axis</code> <code>int</code> <p>axis of <code>input</code> along which to calculate, optional. Defaults to -1.</p> <code>-1</code> <code>order</code> <code>int</code> <p>order of 0 is Gaussian, higher orders are derivatives, optional. Defaults to 0.</p> <code>0</code> <code>truncate</code> <code>float</code> <p>truncate filter at this many std. dev's, optional. Defaults to 4.</p> <code>4.0</code> <code>mode</code> <code>str</code> <p>how input array is extended beyond boundaries, optional. Defaults to 'constant'.</p> <code>'constant'</code> <code>cval</code> <code>float</code> <p>value to use for <code>mode='constant'</code>, optional. Defaults to 0.</p> <code>0.0</code> <code>radius</code> <code>int</code> <p>radius of the filter. Overrides <code>truncate</code> if &gt;0. Defaults to 0.</p> <code>0</code> <code>precision</code> <code>PrecisionLike</code> <p>precision to use for calculation, optional. Defaults to None.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>if radius &lt; 0</p> <p>Returns:</p> Type Description <code>Num[Array, ' a']</code> <p>Array</p>"},{"location":"ndimage/#winx.ndimage.generic_filter","title":"<code>winx.ndimage.generic_filter(x, fun, size, footprint=None, mode='constant', cval=0, origin=0, axes=None)</code>","text":"<p>Calculate a multidimensional filter using the given function.</p> <p>At each element of the input array, a window is generated, centered around that element, and the function is evaluated on that window.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>Array</code> <p>The input array.</p> required <code>fun</code> <code>Callable[[Array], Union[Array, Numeric]]</code> <p>Function to apply at each element.</p> required <code>size</code> <code>int | Sequence[int]</code> <p>Shape that is taken from the input array at every element position to define the input to the filter function. If an integer, a square (cubic, etc.) window with that size in each dimension will be used.</p> required <code>footprint</code> <code>Array</code> <p>A boolean array that delineates a window as well as which of the elements in that window gets passed to the filter function. If this is used, the values selected by the footprint are passed to <code>fun</code> as a 1-dimensional array. When <code>footprint</code> is given, <code>size</code> is ignored.</p> <code>None</code> <code>mode</code> <code>str</code> <p>Determines how the input array will be padded beyond its boundaries. Defaults to 'constant'. For valid values, see <code>jax.numpy.pad</code>.</p> <code>'constant'</code> <code>cval</code> <code>Numeric</code> <p>Value to fill past edges of input if <code>mode</code> is 'constant'. Defaults to 0.</p> <code>0</code> <code>origin</code> <code>int | Sequence[int]</code> <p>Controls the placement of the filter on the input's elements. A value of 0 (the default) centers the filter over the pixel. Positive values shift the filter to the left. Negative values shift the filter to the right.</p> <code>0</code> <code>axes</code> <code>int | Sequence[int]</code> <p>Axes of input array to filter along. If <code>None</code>, the input is filtered along all axes.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If <code>size</code> is specified as a sequence and the Numeric of elements is not the same as the Numeric of dimensions.</p> <p>Returns:</p> Name Type Description <code>Array</code> <code>Array</code> <p>The filtered array.</p> Notes <p>When using the <code>footprint</code> argument, the values passed to the filtering function will be a 1d array sorted in descending order.</p>"},{"location":"ndimage/#winx.ndimage.maximum_filter","title":"<code>winx.ndimage.maximum_filter(x, size, footprint=None, mode='constant', cval=0, origin=0, axes=None)</code>","text":"<p>Compute a multidimensional maximum filter.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>Array</code> <p>The input array.</p> required <code>size</code> <code>int | Sequence[int]</code> <p>Shape that is taken from the input array at every element position to define the input to the filter function. If an integer, a square (cubic, etc.) window with that size in each dimension will be used.</p> required <code>footprint</code> <code>Array</code> <p>A boolean array that delineates a window as well as which of the elements in that window gets passed to the filter function. If this is used, the values selected by the footprint are passed to <code>fun</code> as a 1-dimensional array. When <code>footprint</code> is given, <code>size</code> is ignored.</p> <code>None</code> <code>mode</code> <code>str</code> <p>Determines how the input array will be padded beyond its boundaries. Defaults to 'constant'. For valid values, see <code>jax.numpy.pad</code>.</p> <code>'constant'</code> <code>cval</code> <code>Numeric</code> <p>Value to fill past edges of input if <code>mode</code> is 'constant'. Defaults to 0.</p> <code>0</code> <code>origin</code> <code>int | Sequence[int]</code> <p>Controls the placement of the filter on the input's elements. A value of 0 (the default) centers the filter over the pixel. Positive values shift the filter to the left. Negative values shift the filter to the right.</p> <code>0</code> <code>axes</code> <code>int | Sequence[int]</code> <p>Axes of input array to filter along. If <code>None</code>, the input is filtered along all axes.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Array</code> <code>Array</code> <p>Maximum-filtered array.</p>"},{"location":"ndimage/#winx.ndimage.median_filter","title":"<code>winx.ndimage.median_filter(x, size, footprint=None, mode='constant', cval=0, origin=0, axes=None)</code>","text":"<p>Compute a multidimensional median filter.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>Array</code> <p>The input array.</p> required <code>size</code> <code>int | Sequence[int]</code> <p>Shape that is taken from the input array at every element position to define the input to the filter function. If an integer, a square (cubic, etc.) window with that size in each dimension will be used.</p> required <code>footprint</code> <code>Array</code> <p>A boolean array that delineates a window as well as which of the elements in that window gets passed to the filter function. If this is used, the values selected by the footprint are passed to <code>fun</code> as a 1-dimensional array. When <code>footprint</code> is given, <code>size</code> is ignored.</p> <code>None</code> <code>mode</code> <code>str</code> <p>Determines how the input array will be padded beyond its boundaries. Defaults to 'constant'. For valid values, see <code>jax.numpy.pad</code>.</p> <code>'constant'</code> <code>cval</code> <code>Numeric</code> <p>Value to fill past edges of input if <code>mode</code> is 'constant'. Defaults to 0.</p> <code>0</code> <code>origin</code> <code>int | Sequence[int]</code> <p>Controls the placement of the filter on the input's elements. A value of 0 (the default) centers the filter over the pixel. Positive values shift the filter to the left. Negative values shift the filter to the right.</p> <code>0</code> <code>axes</code> <code>int | Sequence[int]</code> <p>Axes of input array to filter along. If <code>None</code>, the input is filtered along all axes.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Array</code> <code>Array</code> <p>Median-filtered array.</p>"},{"location":"ndimage/#winx.ndimage.minimum_filter","title":"<code>winx.ndimage.minimum_filter(x, size, footprint=None, mode='constant', cval=0, origin=0, axes=None)</code>","text":"<p>Compute a multidimensional minimum filter.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>Array</code> <p>The input array.</p> required <code>size</code> <code>int | Sequence[int]</code> <p>Shape that is taken from the input array at every element position to define the input to the filter function. If an integer, a square (cubic, etc.) window with that size in each dimension will be used.</p> required <code>footprint</code> <code>Array</code> <p>A boolean array that delineates a window as well as which of the elements in that window gets passed to the filter function. If this is used, the values selected by the footprint are passed to <code>fun</code> as a 1-dimensional array. When <code>footprint</code> is given, <code>size</code> is ignored.</p> <code>None</code> <code>mode</code> <code>str</code> <p>Determines how the input array will be padded beyond its boundaries. Defaults to 'constant'. For valid values, see <code>jax.numpy.pad</code>.</p> <code>'constant'</code> <code>cval</code> <code>Numeric</code> <p>Value to fill past edges of input if <code>mode</code> is 'constant'. Defaults to 0.</p> <code>0</code> <code>origin</code> <code>int | Sequence[int]</code> <p>Controls the placement of the filter on the input's elements. A value of 0 (the default) centers the filter over the pixel. Positive values shift the filter to the left. Negative values shift the filter to the right.</p> <code>0</code> <code>axes</code> <code>int | Sequence[int]</code> <p>Axes of input array to filter along. If <code>None</code>, the input is filtered along all axes.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Array</code> <code>Array</code> <p>Minimum-filtered array.</p>"},{"location":"ndimage/#winx.ndimage.uniform_filter","title":"<code>winx.ndimage.uniform_filter(x, size, footprint=None, mode='constant', cval=0, origin=0, axes=None)</code>","text":"<p>Compute a multidimensional uniform (AKA \"mean\") filter.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>Array</code> <p>The input array.</p> required <code>size</code> <code>int | Sequence[int]</code> <p>Shape that is taken from the input array at every element position to define the input to the filter function. If an integer, a square (cubic, etc.) window with that size in each dimension will be used.</p> required <code>footprint</code> <code>Array</code> <p>A boolean array that delineates a window as well as which of the elements in that window gets passed to the filter function. If this is used, the values selected by the footprint are passed to <code>fun</code> as a 1-dimensional array. When <code>footprint</code> is given, <code>size</code> is ignored.</p> <code>None</code> <code>mode</code> <code>str</code> <p>Determines how the input array will be padded beyond its boundaries. Defaults to 'constant'. For valid values, see <code>jax.numpy.pad</code>.</p> <code>'constant'</code> <code>cval</code> <code>Numeric</code> <p>Value to fill past edges of input if <code>mode</code> is 'constant'. Defaults to 0.</p> <code>0</code> <code>origin</code> <code>int | Sequence[int]</code> <p>Controls the placement of the filter on the input's elements. A value of 0 (the default) centers the filter over the pixel. Positive values shift the filter to the left. Negative values shift the filter to the right.</p> <code>0</code> <code>axes</code> <code>int | Sequence[int]</code> <p>Axes of input array to filter along. If <code>None</code>, the input is filtered along all axes.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Array</code> <code>Array</code> <p>Uniform-filtered array.</p>"},{"location":"ndimage/#morphology","title":"Morphology","text":"<p>Important differences with the <code>scipy.ndimage</code> API:</p> <ul> <li><code>border_value</code> arguments do not set the value at the border in the output array, like in <code>scipy</code>, but set the value when the input array is padded so that the output shape matches the input shape.</li> <li><code>mask</code> is not included as an input argument. To use a mask, while maintaining JAX-transformability, one can use <code>jnp.where</code> in combination with the <code>binary_</code> operations.</li> </ul>"},{"location":"ndimage/#winx.ndimage.binary_dilation","title":"<code>winx.ndimage.binary_dilation(x, size, structure=None, iterations=1, border_value=False, origin=0, axes=None)</code>","text":"<p>Compute the binary dilation of the input array with the given structuring element.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>Bool[Array, ...]</code> <p>Input array.</p> required <code>size</code> <code>int | Sequence[int]</code> <p>Shape of the array of ones that will be used as a structuring element.</p> required <code>structure</code> <code>Optional[Array]</code> <p>Structuring element. If <code>None</code>, the argument from <code>size</code> is used.</p> <code>None</code> <code>iterations</code> <code>int</code> <p>Numeric of times to repeat the dilation. Defaults to 1.</p> <code>1</code> <code>border_value</code> <code>bool</code> <p>Value at the border when padding. Defaults to False.</p> <code>False</code> <code>origin</code> <code>Union[int, Sequence[int]]</code> <p>Placement of the filter. Defaults to 0.</p> <code>0</code> <code>axes</code> <code>Optional[int | Sequence[int]]</code> <p>The axes over which to apply the filter. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Bool[Array, ...]</code> <p>Bool[Array]: Dilation of the input.</p>"},{"location":"ndimage/#winx.ndimage.binary_erosion","title":"<code>winx.ndimage.binary_erosion(x, size, structure=None, iterations=1, border_value=False, origin=0, axes=None)</code>","text":"<p>Compute the multidimensional binary erosion with the given structuring element.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>Bool[Array, ...]</code> <p>Input array.</p> required <code>size</code> <code>int | Sequence[int]</code> <p>Shape of the array of ones that will be used as a structuring element.</p> required <code>structure</code> <code>Optional[Array]</code> <p>Structuring element. If <code>None</code>, the argument from <code>size</code> is used.</p> <code>None</code> <code>iterations</code> <code>int</code> <p>Numeric of times to repeat the erosion. Defaults to 1.</p> <code>1</code> <code>border_value</code> <code>bool</code> <p>Value at the border when padding. Defaults to False.</p> <code>False</code> <code>origin</code> <code>Union[int, Sequence[int]]</code> <p>Placement of the filter. Defaults to 0.</p> <code>0</code> <code>axes</code> <code>Optional[int | Sequence[int]]</code> <p>The axes over which to apply the filter. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Bool[Array, ...]</code> <p>Bool[Array]: Erosion of the input.</p>"},{"location":"ndimage/#winx.ndimage.binary_opening","title":"<code>winx.ndimage.binary_opening(x, size, structure=None, iterations=1, border_value=False, origin=0, axes=None)</code>","text":"<p>Compute the binary opening of the input array.</p> <p>Morphological opening is the dilation of the erosion of the input.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>Bool[Array, ...]</code> <p>Input array.</p> required <code>size</code> <code>int | Sequence[int]</code> <p>Shape of the array of ones that will be used as a structuring element.</p> required <code>structure</code> <code>Optional[Array]</code> <p>Structuring element. If <code>None</code>, the argument from <code>size</code> is used.</p> <code>None</code> <code>iterations</code> <code>int</code> <p>Numeric of times to repeat the dilation. Defaults to 1.</p> <code>1</code> <code>border_value</code> <code>bool</code> <p>Value at the border when padding. Defaults to False.</p> <code>False</code> <code>origin</code> <code>Union[int, Sequence[int]]</code> <p>Placement of the filter. Defaults to 0.</p> <code>0</code> <code>axes</code> <code>Optional[int | Sequence[int]]</code> <p>The axes over which to apply the filter. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Bool[Array, ...]</code> <p>Bool[Array]: morphological closing of input</p>"},{"location":"ndimage/#winx.ndimage.binary_closing","title":"<code>winx.ndimage.binary_closing(x, size, structure=None, iterations=1, border_value=False, origin=0, axes=None)</code>","text":"<p>Compute the binary closing of the input array.</p> <p>Morphological closing is the erosion of the dilation of the input.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>Bool[Array, ...]</code> <p>Input array.</p> required <code>size</code> <code>int | Sequence[int]</code> <p>Shape of the array of ones that will be used as a structuring element.</p> required <code>structure</code> <code>Optional[Array]</code> <p>Structuring element. If <code>None</code>, the argument from <code>size</code> is used.</p> <code>None</code> <code>iterations</code> <code>int</code> <p>Numeric of times to repeat the dilation. Defaults to 1.</p> <code>1</code> <code>border_value</code> <code>bool</code> <p>Value at the border when padding. Defaults to False.</p> <code>False</code> <code>origin</code> <code>Union[int, Sequence[int]]</code> <p>Placement of the filter. Defaults to 0.</p> <code>0</code> <code>axes</code> <code>Optional[int | Sequence[int]]</code> <p>The axes over which to apply the filter. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Bool[Array, ...]</code> <p>Bool[Array]: morphological closing of input</p>"},{"location":"ndimage/#winx.ndimage.binary_dilation","title":"<code>winx.ndimage.binary_dilation(x, size, structure=None, iterations=1, border_value=False, origin=0, axes=None)</code>","text":"<p>Compute the binary dilation of the input array with the given structuring element.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>Bool[Array, ...]</code> <p>Input array.</p> required <code>size</code> <code>int | Sequence[int]</code> <p>Shape of the array of ones that will be used as a structuring element.</p> required <code>structure</code> <code>Optional[Array]</code> <p>Structuring element. If <code>None</code>, the argument from <code>size</code> is used.</p> <code>None</code> <code>iterations</code> <code>int</code> <p>Numeric of times to repeat the dilation. Defaults to 1.</p> <code>1</code> <code>border_value</code> <code>bool</code> <p>Value at the border when padding. Defaults to False.</p> <code>False</code> <code>origin</code> <code>Union[int, Sequence[int]]</code> <p>Placement of the filter. Defaults to 0.</p> <code>0</code> <code>axes</code> <code>Optional[int | Sequence[int]]</code> <p>The axes over which to apply the filter. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Bool[Array, ...]</code> <p>Bool[Array]: Dilation of the input.</p>"},{"location":"ndimage/#winx.ndimage.binary_hit_or_miss","title":"<code>winx.ndimage.binary_hit_or_miss(x, structure1, structure2=None, origin1=0, origin2=0, axes=None)</code>","text":"<p>Compute the binary hit or miss transform for the input using the two structures.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>Bool[Array, ...]</code> <p>Input array.</p> required <code>structure1</code> <code>Bool[Array, ...]</code> <p>pattern in the input array to look for (matches foreground).</p> required <code>structure2</code> <code>Optional[Bool[Array, ...]]</code> <p>Structure that must not match any of the foreground pixels.</p> <code>None</code> <code>origin1</code> <code>Union[int, Sequence[int]]</code> <p>Placement of first structuring element. Defaults to 0.</p> <code>0</code> <code>origin2</code> <code>Union[int, Sequence[int]]</code> <p>Placement of second structuring element. Defaults to 0.</p> <code>0</code> <code>axes</code> <code>Optional[int | Sequence[int]]</code> <p>The axes over which to apply the filter. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Bool[Array, ...]</code> <p>Bool[Array]</p>"},{"location":"ndimage/#winx.ndimage.grey_erosion","title":"<code>winx.ndimage.grey_erosion(x, size, structure=None, iterations=1, border_value=0, origin=0, axes=None)</code>","text":"<p>Multidimensional greyscale erosion with the given structuring element.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>Num[Array, ...]</code> <p>Input array.</p> required <code>size</code> <code>int | Sequence[int]</code> <p>Shape of the array of ones that will be used as a structuring element.</p> required <code>structure</code> <code>Optional[Array]</code> <p>Structuring element. If <code>None</code>, the argument from <code>size</code> is used.</p> <code>None</code> <code>iterations</code> <code>int</code> <p>Numeric of times to repeat the erosion. Defaults to 1.</p> <code>1</code> <code>border_value</code> <code>Numeric</code> <p>Value at the border when padding. Defaults to 0.</p> <code>0</code> <code>origin</code> <code>Union[int, Sequence[int]]</code> <p>Placement of the filter. Defaults to 0.</p> <code>0</code> <code>axes</code> <code>Optional[int | Sequence[int]]</code> <p>The axes over which to apply the filter. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Num[Array, ...]</code> <p>Num[Array]: Erosion of the input.</p>"},{"location":"ndimage/#winx.ndimage.grey_opening","title":"<code>winx.ndimage.grey_opening(x, size, structure=None, iterations=1, border_value=0, origin=0, axes=None)</code>","text":"<p>Multidimensional greyscale opening with the given structuring element.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>Num[Array, ...]</code> <p>Input array.</p> required <code>size</code> <code>int | Sequence[int]</code> <p>Shape of the array of ones that will be used as a structuring element.</p> required <code>structure</code> <code>Optional[Array]</code> <p>Structuring element. If <code>None</code>, the argument from <code>size</code> is used.</p> <code>None</code> <code>iterations</code> <code>int</code> <p>Numeric of times to repeat the dilation. Defaults to 1.</p> <code>1</code> <code>border_value</code> <code>Numeric</code> <p>Value at the border when padding. Defaults to 0.</p> <code>0</code> <code>origin</code> <code>Union[int, Sequence[int]]</code> <p>Placement of the filter. Defaults to 0.</p> <code>0</code> <code>axes</code> <code>Optional[int | Sequence[int]]</code> <p>The axes over which to apply the filter. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Num[Array, ...]</code> <p>Num[Array]: Greyscale opening of the input.</p>"},{"location":"ndimage/#winx.ndimage.grey_closing","title":"<code>winx.ndimage.grey_closing(x, size, structure=None, iterations=1, border_value=0, origin=0, axes=None)</code>","text":"<p>Multidimensional greyscale closing with the given structuring element.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>Num[Array, ...]</code> <p>Input array.</p> required <code>size</code> <code>int | Sequence[int]</code> <p>Shape of the array of ones that will be used as a structuring element.</p> required <code>structure</code> <code>Optional[Array]</code> <p>Structuring element. If <code>None</code>, the argument from <code>size</code> is used.</p> <code>None</code> <code>iterations</code> <code>int</code> <p>Numeric of times to repeat the dilation. Defaults to 1.</p> <code>1</code> <code>border_value</code> <code>Numeric</code> <p>Value at the border when padding. Defaults to 0.</p> <code>0</code> <code>origin</code> <code>Union[int, Sequence[int]]</code> <p>Placement of the filter. Defaults to 0.</p> <code>0</code> <code>axes</code> <code>Optional[int | Sequence[int]]</code> <p>The axes over which to apply the filter. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Num[Array, ...]</code> <p>Num[Array]: Greyscale closing of the input.</p>"},{"location":"ndimage/#winx.ndimage.morphological_gradient","title":"<code>winx.ndimage.morphological_gradient(x, size, structure=None, border_value=0, origin=0, axes=None)</code>","text":"<p>Compute the multidimensional morphological gradient.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>Num[Array, ...]</code> <p>Input array.</p> required <code>size</code> <code>int | Sequence[int]</code> <p>Shape of the array of ones that will be used as a structuring element.</p> required <code>structure</code> <code>Optional[Array]</code> <p>Structuring element. If <code>None</code>, the argument from <code>size</code> is used.</p> <code>None</code> <code>border_value</code> <code>Numeric</code> <p>Value at the border when padding. Defaults to 0.</p> <code>0</code> <code>origin</code> <code>Union[int, Sequence[int]]</code> <p>Placement of the filter. Defaults to 0.</p> <code>0</code> <code>axes</code> <code>Optional[int | Sequence[int]]</code> <p>The axes over which to apply the filter. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Num[Array, ...]</code> <p>Num[Array]: difference between greyscale dilation and erosion.</p>"}]}